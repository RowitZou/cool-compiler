多重继承的使用方法和实现特点：

    1. 重复继承

        被多重继承的类有多个实例。

       (a) 使用方法：

        class A {...};
        class B1 : public A {...};
        class B2 : public A {...};
        class C : public B1, public B2 {...};

       (b) 实现特点：

        不论类B1或类B2都含一个类A的副本，这样在类C的对象布局中将包含两个
    独立的类A子对象。布局顺序为：A -> B1附加 -> A -> B2附加 -> C附加。当
    A的特征被用于访问、调用和覆盖的时候，会导致冲突和二义。在C++中，受限
    算符“::”可以用于B1::f的形式来表示特性f属于B1，这样就能显示地消除二义。
    对于成员函数，无论是哪一个类A子对象，指向的都是同一函数地址。


    2. 虚拟继承

        被多重继承的类只能有一个实例。

       (a) 使用方法：

        class A {...};
        class B1 : virtual public A {...};
        class B2 : virtual public A {...};
        class C : public B1, public B2 {...};

       (b) 实现特点：

       采用虚拟继承后，C的对象布局中将只包含一个类A的子对象。布局顺序为：
    B1附加 -> B2附加 -> C附加 -> A。即先安排好确定的局部，再建立其共享的
    部分。由于只存在一个A的子对象，也就没有了重复子对象的二义性问题。


编写程序时的主要错误及出错原因：

    1.
    出现错误：

        在编写多重继承的类之后，访问多实例A的数据成员时，用g++编译提示有
    如下错误：error: request for member ‘a’ is ambiguous.

    原因：

        由于A具有多实例，访问时必须指明以消除歧义。将c1.a改为c1.B1::a即可。

    2.
    出现错误：

        在试图用cout输出方法成员的地址时，只能输出BOOL值1.

    原因：

        如果是非静态的成员函数，cout不能输出地址，而是输出bool值。因为<<
    并没有对void(_thiscall A::*)()类型重载，编译器将这种类型转换为BOOL类
    型。而静态函数并非_thiscall，<<有对它的重载，因此类的静态函数可以直接
    用cout输出函数地址。解决方法为，将函数地址强制转换为void*类型，从而进
    行方法成员地址的输出，但此方法用g++编译会报warning，用clang则直接报错。





